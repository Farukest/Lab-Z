import { expect } from "chai";
import { ethers, fhevm } from "hardhat";
import { FhevmType } from "@fhevm/hardhat-plugin";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";

describe("{{CONTRACT_NAME}}", function () {
  let contract: any;
  let contractAddress: string;
  let signers: HardhatEthersSigner[];

  before(async function () {
    signers = await ethers.getSigners();
  });

  beforeEach(async function () {
    const Factory = await ethers.getContractFactory("{{CONTRACT_NAME}}");
    contract = await Factory.deploy();
    await contract.waitForDeployment();
    contractAddress = await contract.getAddress();
  });

  describe("Increment", function () {
    it("should increment the counter with encrypted value", async function () {
      const [signer] = signers;
      const valueToAdd = 5;

      // Create encrypted input using hardhat plugin
      const encryptedInput = await fhevm
        .createEncryptedInput(contractAddress, signer.address)
        .add32(valueToAdd)
        .encrypt();

      // Call increment with encrypted value and proof
      const tx = await contract
        .connect(signer)
        .increment(encryptedInput.handles[0], encryptedInput.inputProof);
      await tx.wait();

      // Get the encrypted count
      const encryptedCount = await contract.getCount();
      expect(encryptedCount).to.not.equal(ethers.ZeroHash);
    });

    it("should allow multiple increments", async function () {
      const [signer] = signers;

      // First increment
      const encrypted1 = await fhevm
        .createEncryptedInput(contractAddress, signer.address)
        .add32(10)
        .encrypt();
      await contract.connect(signer).increment(encrypted1.handles[0], encrypted1.inputProof);

      // Second increment
      const encrypted2 = await fhevm
        .createEncryptedInput(contractAddress, signer.address)
        .add32(20)
        .encrypt();
      await contract.connect(signer).increment(encrypted2.handles[0], encrypted2.inputProof);

      const encryptedCount = await contract.getCount();
      expect(encryptedCount).to.not.equal(ethers.ZeroHash);
    });
  });

  describe("Decrement", function () {
    it("should decrement the counter with encrypted value", async function () {
      const [signer] = signers;

      // First add some value
      const addValue = await fhevm
        .createEncryptedInput(contractAddress, signer.address)
        .add32(100)
        .encrypt();
      await contract.connect(signer).increment(addValue.handles[0], addValue.inputProof);

      // Then decrement
      const subValue = await fhevm
        .createEncryptedInput(contractAddress, signer.address)
        .add32(30)
        .encrypt();
      await contract.connect(signer).decrement(subValue.handles[0], subValue.inputProof);

      const encryptedCount = await contract.getCount();
      expect(encryptedCount).to.not.equal(ethers.ZeroHash);
    });
  });

  describe("Access Control", function () {
    it("should grant access to caller after increment", async function () {
      const [signer] = signers;

      const encrypted = await fhevm
        .createEncryptedInput(contractAddress, signer.address)
        .add32(1)
        .encrypt();
      await contract.connect(signer).increment(encrypted.handles[0], encrypted.inputProof);

      // Caller should be able to get the count
      const count = await contract.connect(signer).getCount();
      expect(count).to.not.equal(ethers.ZeroHash);
    });
  });

  {{TEST_EXTENSIONS}}
});
